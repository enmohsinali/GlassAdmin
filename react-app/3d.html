<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Abstract Glowing Sphere â€” Three.js + Shader</title>
  <style>
    html,body {
      height: 100%;
      margin: 0;
      background: #000;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      overflow: hidden;
    }
    #canvas-container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    .info {
      position: absolute;
      left: 12px;
      bottom: 12px;
      color: rgba(255,255,255,0.8);
      font-size: 12px;
      backdrop-filter: blur(4px);
      padding: 6px 8px;
      border-radius: 6px;
      pointer-events: none;
    }
    a { color: #9cf; text-decoration: none; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div class="info">Drag to rotate, scroll to zoom. Use the GUI to tweak the look.</div>

  <!-- Map the bare import "three" to a CDN module so examples that import "three" resolve -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18.0/dist/lil-gui.esm.min.js';

    // --- Scene + Renderer ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    // --- Camera ---
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
    camera.position.set(0, 0, 6);

    // --- Controls ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    // --- Lights ---
    const ambient = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambient);

    const pointA = new THREE.PointLight(0xff66ff, 1.2, 20);
    pointA.position.set(5, 3, 5);
    scene.add(pointA);

    const pointB = new THREE.PointLight(0x66b3ff, 0.9, 20);
    pointB.position.set(-5, -3, -5);
    scene.add(pointB);

    // --- Shader material ---
    const sphereVertex = /* glsl */`
      varying vec3 vPos;
      varying vec2 vUv;
      uniform float uTime;
      uniform float uNoiseScale;
      uniform float uNoiseAmplitude;

      vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
      vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

      float snoise(vec3 v){
        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i  = floor(v + dot(v, C.yyy) );
        vec3 x0 =   v - i + dot(i, C.xxx) ;
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute( permute( permute(
                  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        float n_ = 1.0/7.0;
        vec3  ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_ );
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;
        vec3 p0 = vec3(a0.xy,h.x);
        vec3 p1 = vec3(a0.zw,h.y);
        vec3 p2 = vec3(a1.xy,h.z);
        vec3 p3 = vec3(a1.zw,h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                      dot(p2,x2), dot(p3,x3) ) );
      }

      void main(){
        vUv = uv;
        vPos = position;
        vec3 noisePos = vec3(position * uNoiseScale) + vec3(uTime * 0.1);
        float n = snoise(noisePos);
        float displacement = n * uNoiseAmplitude;
        vec3 newPos = position + normal * displacement;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
      }
    `;

    const sphereFragment = /* glsl */`
      precision highp float;
      varying vec3 vPos;
      varying vec2 vUv;

      uniform float uTime;
      uniform vec3 uColorA;
      uniform vec3 uColorB;
      uniform float uGlowStrength;
      uniform float uContrast;
      uniform float uNoiseScale;
      uniform float uNoiseAmplitude;

      vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
      vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
      float snoise(vec3 v){
        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i  = floor(v + dot(v, C.yyy) );
        vec3 x0 =   v - i + dot(i, C.xxx) ;
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute( permute( permute(
                  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        float n_ = 1.0/7.0;
        vec3  ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_ );
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;
        vec3 p0 = vec3(a0.xy,h.x);
        vec3 p1 = vec3(a0.zw,h.y);
        vec3 p2 = vec3(a1.xy,h.z);
        vec3 p3 = vec3(a1.zw,h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                      dot(p2,x2), dot(p3,x3) ) );
      }

      void main(){
        float n = snoise(vec3(vPos * uNoiseScale) + vec3(uTime * 0.08));
        float pattern = smoothstep(-0.4, 0.6, n + sin(vUv.y * 8.0 + uTime * 0.6) * 0.25);
        vec3 color = mix(uColorA, uColorB, pattern);
        float fresnel = pow(1.0 - abs(dot(normalize(vPos), vec3(0.0,0.0,1.0))), 2.0);
        float glow = pow(max(0.0, fresnel + n * 0.4), 1.5) * uGlowStrength;
        vec3 finalColor = color * (0.6 + glow) * uContrast;
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;

    const uniforms = {
      uTime: { value: 0.0 },
      uColorA: { value: new THREE.Color(0x6ea8ff) },
      uColorB: { value: new THREE.Color(0xd36bff) },
      uNoiseScale: { value: 1.8 },
      uNoiseAmplitude: { value: 0.45 },
      uGlowStrength: { value: 1.2 },
      uContrast: { value: 1.0 }
    };

    const material = new THREE.ShaderMaterial({
      vertexShader: sphereVertex,
      fragmentShader: sphereFragment,
      uniforms,
      side: THREE.FrontSide
    });

    // --- Mesh and geometry ---
    let sphereMesh;
    function buildSphere(detail = 128) {
      if (sphereMesh) {
        sphereMesh.geometry.dispose();
        scene.remove(sphereMesh);
      }
      const geometry = new THREE.IcosahedronGeometry(1.3, Math.max(2, Math.floor(detail/32)));
      sphereMesh = new THREE.Mesh(geometry, material);
      scene.add(sphereMesh);
    }
    buildSphere(128);

    // --- Postprocessing (bloom) ---
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 0.9, 0.4, 0.85);
    bloomPass.threshold = 0.0;
    bloomPass.strength = 1.2;
    bloomPass.radius = 0.6;
    composer.addPass(bloomPass);

    // --- GUI ---
    const gui = new GUI();
    const params = {
      colorA: '#6ea8ff',
      colorB: '#d36bff',
      noiseScale: uniforms.uNoiseScale.value,
      noiseAmplitude: uniforms.uNoiseAmplitude.value,
      glow: uniforms.uGlowStrength.value,
      contrast: uniforms.uContrast.value,
      bloomStrength: bloomPass.strength,
      bloomRadius: bloomPass.radius,
      bloomThreshold: bloomPass.threshold,
      rotationSpeed: 0.2,
      autoRotate: true,
      detail: 128,
      ambientIntensity: ambient.intensity,
      pointAIntensity: pointA.intensity,
      pointBIntensity: pointB.intensity
    };

    gui.addColor(params, 'colorA').name('Color A').onChange(v => uniforms.uColorA.value.set(v));
    gui.addColor(params, 'colorB').name('Color B').onChange(v => uniforms.uColorB.value.set(v));
    gui.add(params, 'noiseScale', 0.2, 6).name('Noise Scale').onChange(v => uniforms.uNoiseScale.value = v);
    gui.add(params, 'noiseAmplitude', 0.0, 1.6).name('Noise Amp').onChange(v => uniforms.uNoiseAmplitude.value = v);
    gui.add(params, 'glow', 0.0, 3.0).name('Glow Strength').onChange(v => uniforms.uGlowStrength.value = v);
    gui.add(params, 'contrast', 0.5, 2.5).name('Contrast').onChange(v => uniforms.uContrast.value = v);
    gui.add(params, 'bloomStrength', 0.0, 3.0).name('Bloom Strength').onChange(v => bloomPass.strength = v);
    gui.add(params, 'bloomRadius', 0.0, 1.5).name('Bloom Radius').onChange(v => bloomPass.radius = v);
    gui.add(params, 'bloomThreshold', 0.0, 1.0).name('Bloom Threshold').onChange(v => bloomPass.threshold = v);
    gui.add(params, 'rotationSpeed', 0.0, 2.0).name('Rotation Speed');
    gui.add(params, 'autoRotate').name('Auto Rotate');
    gui.add(params, 'detail', 32, 512, 1).name('Geometry Detail').onChange(v => buildSphere(v));
    gui.add(params, 'ambientIntensity', 0.0, 1.5).name('Ambient').onChange(v => ambient.intensity = v);
    gui.add(params, 'pointAIntensity', 0.0, 3.0).name('Point A Int').onChange(v => pointA.intensity = v);
    gui.add(params, 'pointBIntensity', 0.0, 3.0).name('Point B Int').onChange(v => pointB.intensity = v);

    // --- Resize handling ---
    function onWindowResize(){
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      composer.setSize(w, h);
    }
    window.addEventListener('resize', onWindowResize, false);

    // --- Animation loop ---
    const clock = new THREE.Clock();
    let lastTime = 0;
    function animate(){
      const t = clock.getElapsedTime();
      uniforms.uTime.value = t;
      const dt = t - lastTime;
      lastTime = t;

      if (params.autoRotate && sphereMesh) {
        sphereMesh.rotation.y += dt * params.rotationSpeed * 0.2;
        sphereMesh.rotation.x += dt * params.rotationSpeed * 0.05;
      }

      controls.update();
      composer.render();
      requestAnimationFrame(animate);
    }
    animate();

    // --- Mouse reactive lights ---
    let mouse = new THREE.Vector2(0, 0);
    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      pointA.position.x = 5 + mouse.x * 2.5;
      pointA.position.y = 3 + mouse.y * 2.5;
      pointB.position.x = -5 + mouse.x * -2.5;
      pointB.position.y = -3 + mouse.y * -2.5;
    }, { passive: true });

    uniforms.uColorA.value.set(params.colorA);
    uniforms.uColorB.value.set(params.colorB);

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        renderer.setAnimationLoop(null);
      } else {
        lastTime = clock.getElapsedTime();
        animate();
      }
    });

    window.__APP = { scene, camera, renderer, composer, uniforms, params, bloomPass };
  </script>
</body>
</html>
